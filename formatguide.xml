<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="styleguide.xsl"?>
<GUIDE title="STAR C++ Naming &amp; Formatting Guidelines">
    

    <address>
        Authors:<br/>
        Mustafa Mustafa <br/>
        Thomas Ullrich <br/>
        Anselm Vossen <br/>
    </address>
    
    <address><p><em>Version 1.0, June 24, 2015</em></p></address>
   
    <CATEGORY title="Introduction">
        <p>
            This is a document of the naming &amp; formatting guidelines compiled for the STAR
            collaboration by the above mentioned authors. This effort was initiated by the STAR
            computing coordinator Jerome Lauret on October 31, 2014. The charge can be
            viewed <a href="charge.txt">here</a>. The committee produced two documents, one for the
            naming &amp; formatting guidelines  seen here, and one for C++ coding guidelines that
            can be viewed <a href="codingguide.xml">here</a>.
        </p>
        
        <p>
            The committee based their work on the existing guidelines, expanded them for clarity, and
            added new material where it saw fit. We have made heavy use of the Google Style guide
            at <a href="http://google-styleguide.googlecode.com"> http://google-styleguide.googlecode.com</a>
            using their xml and css style sheets. Some of the guidelines included are from the original
            Google document, some were modified versions by the ALICE collaboration. Where they matched
            the STAR guidelines we used their text to minimize efforts.
        </p>
        
        <p>
            The goal of this guide is to provide a number of rules that keep the code base manageable
            by enforcing <em>consistency</em>.
            
            It is very important that any programmer
            can look at another programmer's code and understand it quickly.
            Maintaining a uniform style and following conventions means that "pattern-matching" can be
            more easily used to identify different symbols and invariants.
        </p>
        <p>
            Creating common, required
            idioms and patterns makes code much easier to understand.  In some
            cases there might be good arguments for changing certain style rules.
            Nonetheless, for reasons of consistency the rules are left unchanged.
        </p>
        
        
    </CATEGORY>
   
<OVERVIEW>
    <CATEGORY title="Important Note">
        <STYLEPOINT title="Displaying Hidden Details in this Guide">
            <SUMMARY>
                This style guide contains many details that are initially
                hidden from view.  They are marked by the triangle icon, which you
                see here on your left. The first level of hidden information is
                the subsection <i>Summary</i> in each rule and the second level of hidden information is the
                optional subsection <i>Extra details and exceptions to the rule</i>. Click the arrow on the
                left now, you should see "Hooray" appear below.
            </SUMMARY>
            <BODY>
                <p>
                    Hooray!  Now you know you can expand points to get more
                    details.  Alternatively, there are an "expand all summaries"
                    and an "expand all summaries and extra details" at the
                    top of this document.
                </p>
            </BODY>
        </STYLEPOINT>
    </CATEGORY>
    
</OVERVIEW>

    <CATEGORY title="Naming">
        <p>
            The most important consistency rules are those that govern
            naming. The style of a name immediately informs us what sort of
            thing the named entity is: a type, a variable, a function, a macro, etc., without requiring us to search for the
            declaration of that entity. The pattern-matching engine in our
            brains relies a great deal on these naming rules.
        </p>
        <p>
            Naming rules are pretty arbitrary, but we feel that consistency is more important than individual preferences in this area, so regardless of whether you find them sensible or not, the rules are the rules.
        </p>
        
        <STYLEPOINT title="General Naming Rules">
            <SUMMARY>
                Names should be meaningful; abbreviations should be avoided.
                They follow camel case convention. Types and variables, as well as
                access functions should be nouns,
                while functions should be "command" verbs.
            </SUMMARY>
            <BODY>
                <SUBSECTION title="How to Name">
                    <p>
                        Within reason, give as descriptive a name as possible. Do
                        not worry about saving horizontal space as it is far more
                        important to make your code immediately understandable to a
                        new reader. Examples of well-chosen names:
                    </p>
                    <CODE_SNIPPET>
                        int numberOfErrors;               // Good.
                        int numberOfCompletedConnections; // Good.
                    </CODE_SNIPPET>
                    <p>
                        Poorly chosen names use ambiguous abbreviations or arbitrary
                        characters that do not convey meaning.
                        Do not use directly the variable names from mathematical formulas.
                        In mathematics, variable names are usually limited to a single letter.
                        To implement a mathematical formula use variable names that
                        clearly indicate what value it holds.
                    </p>
                    <CODE_SNIPPET>
                        float distance = velocity * time; // Good - no ambiguity
                    </CODE_SNIPPET>
                    <BAD_CODE_SNIPPET>
                        int n;           // Bad - meaningless.
                        int nerr;        // Bad - ambiguous abbreviation.
                        int nCompConns;  // Bad - ambiguous abbreviation.
                        float s = v * t; // Bad - almost meaningless.
                    </BAD_CODE_SNIPPET>
                    <p>
                        Type and variable names should typically be nouns: e.g.,
                        <code>FileOpener</code>, <code>numberOfErrors</code>.
                    </p>
                    <p>
                        Function names should typically be imperative (that is they
                        should be commands): e.g., <code>openFile()</code>,
                        <code>setNumberOfErrors()</code>.
                    </p>
                </SUBSECTION>
                
                <SUBSECTION title="CamelCase Convention">
                    <p>
                        All names in C++ code follow camel case convention. This is
                        the practice of writing compound words so that each word
                        begins with a capital letter. No underscores are allowed.
                    </p>
                    <p>
                        For example:
                    </p>
                    <CODE_SNIPPET>
                        string tableName;   // Good
                    </CODE_SNIPPET>
                    <BAD_CODE_SNIPPET>
                        string table_name;  // Bad - uses underscore.
                        string tablename;   // Bad - all lowercase.
                    </BAD_CODE_SNIPPET>
                    <p>Note, that STAR follows the CamelCase convention even for acronyms:
                        <code>StFmsHit</code>, <code>StTpcHit</code>, etc.</p>
                </SUBSECTION>
                
                <SUBSECTION title="Capitalization Rules">
                    <p>
                        Variables and functions start with a lowercase letter.<br/>
                        Everything else in C++ code (namespaces, type names, constant
                        expressions) starts with an uppercase letter.
                    </p>
                </SUBSECTION>
                
                <SUBSECTION title="Abbreviations">
                    <p>
                        Do not use abbreviations except for acronyms. For example:
                    </p>
                    <CODE_SNIPPET>
                        // Good. These show proper names with no abbreviations.
                        int numberOfDnsConnections;   // Most people know what "DNS" stands for.
                        int priceCount;               // Price count, it makes sense.
                        int daqRate;                  // In STAR everyone knows what DAQ stands for.
                    </CODE_SNIPPET>
                    <BAD_CODE_SNIPPET>
                        // Bad. Abbreviations can be confusing or ambiguous outside a small group.
                        int wgcConnections;  // Only your group knows what this stands for.
                        int pcReader;        // Lots of things can be abbreviated "pc".
                    </BAD_CODE_SNIPPET>
                    <p>
                        A single letter variable name can be used for well-known idioms like iterators of integer type and pimpl-idioms (d-pointer).
                    </p>
                    <CODE_SNIPPET>
                        for (int i = 0 ; i &lt; 10 ; i++) { // Good.
                            prices[i] = 0;
                        }
                    </CODE_SNIPPET>
                    <BAD_CODE_SNIPPET>
                        for (auto i = &amp;prices[0]; i &lt; &amp;prices[10]; ++i) { // Bad
                            *i = 0;                        // i is not of integer type
                        }
                    </BAD_CODE_SNIPPET>
                </SUBSECTION>
            </BODY>
        </STYLEPOINT>
 
        <STYLEPOINT title="Specific STAR Naming Rules">
            <SUMMARY>
            Each class name should begin with <code>St</code> and the appropriate three letter acronym (only first letter capitalized) to indicate its origin and prevent name clashes.
            </SUMMARY>
            <BODY>
                <p>
            The <code>St</code> will identify a STAR class to separate it from system, or external libraries classes, e.g.: <code>StTpcTrack</code>.
            The three letter acronym typically reflects the context within STAR in which the class operates (sub-detector, sub-project)
            and reduces the possibility of name clashes for common packages. Classes unrelated to specific packages may retain only the <code>St</code> prefix.</p>
                </BODY>
        </STYLEPOINT>


        <STYLEPOINT title="File Names">
            <p>    </p>
            <SUMMARY>
                C++ code file names are derived from the class names. Following STAR's naming convention they hence always start
                with <code>St</code>.
                Each header file should contain only one or related class declarations for maintainability and for easier retrieval
                of class definitions.
                Files that contain only function code (e.g. Maker) and are unrelated to a specific class should start also with <code>St</code> followed by a descriptive name of the purpose of the code.
            </SUMMARY>
            <BODY>
                <p>
                    C++ implementation files should end in <code>.cxx</code> and header files
                    should end in <code>.h</code>.
                </p>
                <p>
                    Inline functions should go directly into your
                    <code>.h</code> file.
                </p>
                 <p>
                    Examples of acceptable file names:
                </p>
                <CODE_SNIPPET>
                    StTpcHit.h       // The class declaration.
                    StTpcHit.cxx     // The class definition.
                </CODE_SNIPPET>
                <p>
                    Having upper case letters in a file name might theoretically lead to problems for case-insensitive operating systems.
                    However, as the file name corresponds to the class name it seems important to keep the same case as well.
                    Moreover, having two valid class/file names that would collide on a not-case sensitive OS seems extremely unlikely.
                </p>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Type Names">
            <SUMMARY>
                Type names follow camel case convention and start with an upper case letter:
                <code>MyClass</code>, <code>MyEnum</code>.
            </SUMMARY>
            <BODY>
                <p>
                    The names of all types — classes, structs, typedefs, and enums
                    — have the same naming convention. For example:
                </p>
                <CODE_SNIPPET>
                    // classes and structs
                    class UrlTable { ... }
                    class UrlTableTester { ... }
                    struct UrlTableProperties { ... }
                    
                    // typedefs
                    typedef HashMap&lt;UrlTableProperties *, string&gt; PropertiesMap;
                    
                    // enums
                    enum UrlTableErrors { ... }
                </CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Variable Names">
            <SUMMARY>
                Variable names follow camel case convention and start with
                a lower case letter: <code>myLocalVariable</code>.
                <ul>
                    <li>Class member variables are prefixed with <code>m</code>.</li>
                    <li>No <code>m</code> prefix for struct members.</li>
                    <li>Global variables are prefixed with <code>g</code>.</li>
                    <li><code>constexpr</code> variables are capitalized.</li>
                    <li>No additional prefix for <code>const</code>.</li>
                </ul>
            </SUMMARY>
            <BODY>
                <SUBSECTION title="Local Variable names">
                    <p>
                        For example:
                    </p>
                    <CODE_SNIPPET>
                        string tableName;   // Good.
                    </CODE_SNIPPET>
                </SUBSECTION>
                <SUBSECTION title="Class Data Members">
                    <p>
                        Data members (also called instance variables or member
                        variables) are prefixed with <code>m</code>.
                        If the data member is <code>static</code>, prefix the variable with <code>s</code> instead.
                    </p>
                    <CODE_SNIPPET>
                        class Something {
                        private:
                            string mTableName;
                            static int sGlobalState;
                        };
                    </CODE_SNIPPET>
                </SUBSECTION>
                
                <SUBSECTION title="Struct Variables">
                    <p>
                        Data members in structs are named like regular
                        variables.
                    </p>
                    <CODE_SNIPPET>
                        struct UrlTableProperties {
                            string name;
                            int numberOfEntries;
                        }
                    </CODE_SNIPPET>
                </SUBSECTION>
                
                <SUBSECTION title="Global Variables">
                    <p>
                        Global variables,
                        which should be rare in any case, are prefixed with <code>g</code>.
                    </p>
                </SUBSECTION>
                
                <SUBSECTION title="constexpr">
                    <p>
                        A variable declared as <code>constexpr</code> typically is only used as compile-time constant (but may be stored in read-only memory).
                        Therefore it uses the same convention as <code>enum</code>s and uses uppercase CamelCase.
                    </p>
                    <CODE_SNIPPET>
                        constexpr double LightSpeed = 2.99792458e+8;
                    </CODE_SNIPPET>
                </SUBSECTION>
                
                <SUBSECTION title="const">
                    <p>
                        A variable declared as <code>const</code> does not have any additional naming rules.
                        The prefixes describe the scope of the variable.
                        <code>const</code> is just one aspect of the type of the variable.
                    </p>
                    <p>
                        To provide a constant in the public interface consider <code>constexpr</code>,
                        <code>enum</code>, or a (<code>constexpr</code>) function instead.
                    </p>
                </SUBSECTION>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Function Names">
            <SUMMARY>
                Regular functions follow camel case convention and start with a lower case
                letter: <code>myFunction()</code>.
                
                <ul><li>Accessors and mutators match the name of the variable. Accessors should follow the name of the variable (DO NOT prefix it with <code>get</code>) and mutators are prefixed with <code>set</code>, for example:
                    <code>myMemberVariable()</code>, <code>setMyMemberVariable()</code>.</li>
                <li> Functions (including accessors) returning a boolean value should be prefixed with
                    <code>is</code> or <code>has</code>. </li>
                </ul>
            </SUMMARY>
            <BODY>
                <SUBSECTION title="Regular Functions">
                    <p>
                        Example of functions:
                    </p>
                    <CODE_SNIPPET>
                        addTableEntry();
                        deleteUrl();
                    </CODE_SNIPPET>
                    <p>
                        The rule applies also to <code>constexpr</code> functions:
                    </p>
                    <CODE_SNIPPET>
                        constexpr int getFive() { return 5; }
                    </CODE_SNIPPET>
                </SUBSECTION>
                
                <SUBSECTION title="Accessors and Mutators">
                    <p>
                        Accessors and mutators match
                        the name of the variable they are getting and setting. For the latter use
                        the prefixes <code>set</code>. Do not use the <code>get</code> prefix as done in ROOT.
                        The prefix <code>set</code> is not exclusive for mutators and could
                        be used for other functions, if applicable.
                        This shows an excerpt of a class whose instance variable is
                        <code>mNumberOfEntries</code>:
                    </p>
                    <CODE_SNIPPET>
                        class MyClass {
                        public:
                            ...
                            int numberOfEntries() const { return mNumberOfEntries; }
                            void setNumberOfEntries(int val) { mNumberOfEntries = val; }
                        private:
                            int mNumberOfEntries;
                        };
                    </CODE_SNIPPET>
                </SUBSECTION>
                <SUBSECTION title="Functions returning a boolean value">
                    <p>
                        Functions returning a boolean value should be prefixed with
                        <code>is</code> or <code>has</code>:
                    </p>
                    <CODE_SNIPPET>
                        bool isOpen();
                        bool hasZero();
                    </CODE_SNIPPET>
                    <p> This rule applies also to class member functions where <code>is</code> or <code>has</code> replace <code>get</code>:
                    </p>
                    <CODE_SNIPPET>
                        class MyClass {
                        public:
                            void setValid(bool isValid) const { mValid = isValid; }
                            bool isValid() const { return mValid; }
                        private:
                            bool mValid;
                        };
                    </CODE_SNIPPET>
                </SUBSECTION>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Namespace Names">
            <SUMMARY>
                Namespace names follow camel case convention and start with an upper case
                letter: <code>MyNamespace</code>.
            </SUMMARY>
            <BODY>
                <CODE_SNIPPET>
                    namespace MyNamespace {
                    void MyClass::doSomething()
                    {
                        ...
                    }
                    }
                </CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Enumerator Names">
            <SUMMARY>
                Enumerations and enumerators (the type and the values) follow camel case
                convention and start with <code>St</code> followed by an upper case letter:
                <code> StBeamPolarizationAxis</code>, <code>StDetectorId</code>.
                <ul>
                    <li>Enumerators in unscoped enumerations should have a common
                        prefix/postfix derived from the enumerations name. </li>
                    <li>Enum classes are already scoped and therefore the enumerators do not
                        need a prefix/postfix.</li>
                </ul>
            </SUMMARY>
            <BODY>
                <DEFINITION>
                    A <i>scoped</i> enum is one that is declared with the <code>class</code>
                    keyword, as opposed to a <i>traditional</i> enum, which is unscoped and
                    doesn't include the <code>class</code> keyword in its declaration.
                </DEFINITION>
                <p>
                    Unscoped enumerators are exposed to the enclosing scope.
                    Therefore they should be prefixed or postfixed (decided by which position makes the code more prose-like)
                    with the enumeration's name (or a sensible part thereof).
                    All names use uppercase CamelCase.
                </p>
                <p>
                    Example of an unscoped enumeration:
                </p>
                <CODE_SNIPPET>
                    enum Something {
                        SomethingSmall,   // the type name as prefix
                        SomethingBig,
                        SomethingElse
                    };
                    
                    void add(Something);
                    ...
                    add(SomethingSmall);
                    add(SomethingElse);
                </CODE_SNIPPET>
                <p>
                    Another example of an unscoped enumeration whose enumerators are prefixed with just a (sensible) part
                    of the type name.
                </p>
                <CODE_SNIPPET>
                    enum MallocAlignment {
                        AlignOnVector,    // the "Align" prefix taken from the type name
                        AlignOnCacheline,
                        AlignOnPage
                    }
                    
                    template&lt;MallocAlignment A&gt; void* malloc(size_t);
                    ...
                    void* memory = malloc&lt;AlignOnCacheline&gt;(64);
                </CODE_SNIPPET>
                <p>
                    Enum classes (new in C++11) create scoped enumerators.
                    Therefore there is no need for prefixing or postfixing.
                </p>
                <CODE_SNIPPET>
                    enum class Something : int {
                        Small,
                        Big,
                        Unknown
                    };
                    
                    void add(Something);
                    ...
                    add(Something::Small);
                    add(Something::Unknown);
                </CODE_SNIPPET>
                
                The following enum is forbidden unless it is enclosed in a private namespace.
                The names <code>Ok</code> and <code>OutOfMemory</code> are too generic to be added to the global namespace.
                <BAD_CODE_SNIPPET>
                    enum UrlTableErrors {
                        Ok,                 // Bad.
                        OutOfMemory         // Bad.
                    };
                </BAD_CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Macro Names">
            <SUMMARY>
                All uppercase letters and underscores, prefixed with ST (for STAR) and the sub/project name, i.e. <code>ST_PROJECT_PKG1_MY_MACRO</code>.
            </SUMMARY>
            <BODY>
                <p>
                    Macros must be named with all uppercase letters and underscores, prefixed with the
                    sub/project name.
                </p>
                <CODE_SNIPPET>
                    #define ST_TRIGGER_BIT_SHIFT_TODAY 2
                </CODE_SNIPPET>
                Be sure to never put an underscore as prefix nor use a double underscore.
                First it doesn't follow our naming convention.
                Second, and more importantly, it is reserved to compiler developers.
                <BAD_CODE_SNIPPET>
                    #define _WRONG
                    #define WRONG__AGAIN
                </BAD_CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="STAR StRoot Makers Naming Standards">
            <SUMMARY>
                This section attempts to explain the code directory structure and layout in STAR
                the rules and assumptions triggered in the make system (cons) solely on the basis
                of the name choice the existing exceptions to the rules.
            </SUMMARY>
            <BODY>
                <p>The following naming convention keeps consistency between STAR code and
                    packages written by many users.
                    Not only it enables users to
                    have a feel for what-does-what but also, it allows managers to define basic
                    default set of compilation rules depending
                    sometimes naming convention. Naming conventions
                    in general are fundamental to all large projects
                    and although N
                    users will surely have N best-solution,
                    the rules should be enforced as much as possible.</p>
                
                <SUBSECTION title="The Directory Structure Under the StRoot Tree">
                    <p>The <code>StRoot/</code> tree Is of the following form:</p>
                    <table>
                        <tr>
                            <td><code>StRoot</code></td>
                            <td><code>XXX/</code></td>
                            <td>Only base class that should be freely named. Example: <code>StarClassLibrary</code>,
                                <code>StarRoot</code>, <code>Star2Root</code>.
                                <p>User discouraged, request should be accompanied with a strong reasoning.</p> </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td><code>StXXX/</code></td>
                            <td>A directory tree which will contain a base class many makers will use and derive from.
                                In this category, <code>XXX</code> can be anything. For example, <code>StChain</code>,
                                <code>StEvent</code>, <code>StEventUtilities</code>.
                                <p>User discouraged, request should be accompanied with a strong reasoning.</p>
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td><code>StXXXMaker/</code></td>
                            <td>A tree for a Maker, that is, code compiled in this tree will be assembled as
                                one self-sufficient package. A maker is a particular class deriving from
                                <code>StMaker</code>. Its purpose is to run from within a chain (<code>StChain</code>)
                                of makers and perform a specific task.
                                
                                <p>In this category, sub-name convention are as follows:</p>
                                <ul>
                                    <li> <code>StXXXDbMaker</code> a maker containing the database
                                        calls for the sub-system <code>XXX</code></li>
                                    <li>  <code>StXXXSimulationMaker</code> or <code>StXXXSimulatorMaker</code>
                                        a simulation maker for the subsystem <code>XXX</code></li>
                                    <li>  <code>StXXXCalibMaker</code> or <code>StXXXCalibrationMaker</code>
                                        a calibration maker for the sub-system <code>XXX</code></li>
                                    <li>  <code>StXXXMixerMaker</code> a data/simulation mixer code
                                        for he sub-system <code>XXX</code></li>
                                    <li>  <code>StXXXDisplayMaker</code> a self-explained named
                                        Graphical tool</li>
                                    <li>  <code>StXXTagMaker</code> a maker collecting tags for
                                        the sub-system or analysis <code>XXX</code></li>
                                </ul>
                                while <code>XXX</code> is in principle a detector sub-system identification
                                (3 to 4 letters uniquely designating the sub-system), it may also be anything
                                but a detector sub-system (<code>StAssociationMaker</code>,
                                <code>StMiniMcMaker</code>, <code>StDbMaker</code>) or of the
                                form <code>XXX</code>=analysis or physics study.</td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td><code>StXXXRaw*/</code></td>
                            <td>Any directory with named with the word Raw will make our make system
                                include the necessary path for the Run-Time-System DAQ reader files
                                automatically. This convention is additive to any other description
                                and convention herein.
                                
                                <p>Example: <code>StEmcRawMaker</code> is a "maker" as described above)
                                    and a code base using the DAQ reader and so would be the expectation
                                    for <code>Stl3RawReaderMaker</code> or <code>StFgtRawMaker</code>.</p></td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td><code>StXXXUtil/</code> and <code>StXXXUtilities/</code> </td>
                            <td>Code compiled in a Util or Utilities tree should be code which do
                                not perform any action (nor a maker) but constitute by itself a set
                                of utility classes and functions. Other classes may depend on a
                                Utility library.
                                <ul>
                                    <li> <code>XXXUtil</code> : <code>XXX</code> IS a sub-system detector.</li>
                                    <li> <code>XXXUtilities</code> : <code>XXX</code> IS NOT a detector
                                        sub-system (this is reserved)</li>
                                </ul>
                            </td>
                            
                        </tr>
                        <tr>
                            <td> </td>
                            <td><code>StXXXPool/</code></td>
                            <td>This tree will contain a set of sub-directories chosen by the user,
                                each sub-directory maybe a self-contained project with no relation
                                with anything else. Each sub-directory will therefore lead to the
                                creation of a separate library. The naming convention for the
                                library creation is as follow :
                                <ul>
                                    <li> If the subdirectory is named like <code>StYYY</code>, the
                                        library will inherit the same name. Beware of potential name
                                        clash in this case</li>
                                    <li> If the subdirectory has an arbitrary name <code>YYY</code>,
                                        the final library name will be have the name <code>StXXXPoolYYY</code>.</li>
                                </ul>
                                The Pool category has some special compilation internal rules: if it
                                does not compile, it may be removed from compilation entirely. As such,
                                codes appearing in Pool directory trees cannot be part of a production
                                maker dependency. A typical usage for this structure is to provide a
                                Pool (or collection) of lose codes not used in production (utility
                                tools for sub-systems, analysis codes or utilities).
                                <code>XXX</code> can be easer a Physics Work Group acronym or a
                                detector sub-system acronym.</td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td><code>StXXXClient</code>/</td>
                            <td>This tree will behave like the Pool trees in terms of library naming creation
                                (separate libraries will be created, one per compilable sub-directory).
                                <code>XXX</code> can be anything relevant for a sub-system. Client directories
                                MUST compile (unlike the pools) and may be part of a dependency of a data
                                processing chain. Its general goal is to provide a different tree structure
                                for a set of code providing a "service" widely used across makers.
                                For example, the Run Time System (RTS) have a Client tree containing DAQ
                                related reading codes.</td>
                        </tr>
                    </table>
                </SUBSECTION>
                <SUBSECTION title="Trees and Implicit/Hidden Rules">
                    <p> </p>
                    <table>
                        <tr>
                            <td><code>StRoot/</code> </td>
                            <td><code>StXXX/</code> and <code>/.</code></td>
                            <td><code>README</code></td>
                            <td>A basic documentation in plain text (not
                                mandatory). If exists, the software guide
                                will display the information contained in
                                this file</td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>doc/</code></td>
                            <td>A directory containing more elaborate
                                documentation, either in html or in LaTeX.
                                Note that if a file named index.html
                                exists, the software guide will link to it.</td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>local/</code></td>
                            <td>A subdirectory containing stand-alone
                                Makefiles for the package and/or
                                standalone configuration files.
                                <p>This directory is persona non grata. It was
                                    introduced due to unfortunate momentary laps of reason,
                                    power surge or extreme special transitional needs.
                                    Do not use.</p>
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>examples/</code></td>
                            <td>A directory having a collection of code
                                using the Maker or utility package of
                                interest (case insensitive)
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>macros/</code></td>
                            <td>A directory containing root macros
                                example making use of the maker
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>kumac/</code></td>
                            <td>This is an obsolete directory name (from
                                staf time) but still considered by the make
                                system. It may also appears in the pams/
                                tree structure.
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>test/</code></td>
                            <td>This directory may contain test programs
                                (executables should in principle not
                                appear in our standard but be assembled)
                                <p>This directory is persona non grata. It was
                                    introduced due to unfortunate momentary laps of reason,
                                    power surge or extreme special transitional needs.
                                    Do not use.</p>
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>html/</code></td>
                            <td>A directory possibly containing cross-linked
                                information for Web purposes.
                                However, note that the documentation is,
                                since 2002, auto-generated via the
                                doxygen documentation system (see the
                                sofi page for more information).
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>images/</code></td>
                            <td>A directory containing images such as
                                bitmap, pixmaps or other images used by
                                your program but NOT assembled by any
                                part of the build process. XPM files
                                necessary for Qt for example should not
                                be placed in this directory as explicit rules
                                exists in <code>cons</code> to handle those (but <code>cons</code>
                                will ignore the xpm placed in <code>images/</code>).
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>wrk/</code> and
                                <code>run/</code></td>
                            <td>Discouraged for users.
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td><code>include/</code></td>
                            <td>A directory containing a set of common
                                include files.
                                <p>This directory is persona non grata. It was
                                    introduced due to unfortunate momentary laps of reason,
                                    power surge or extreme special transitional needs.
                                    Do not use.</p>
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td>Any other name</td>
                            <td>Will be searched for code one level down
                                only.
                                All compiled code will be assembled in
                                one library named after to <code>StXXX...</code>.
                                Each sub-directory will be compiled
                                separately that is, each must contain code
                                using explicit include path as the only
                                default search paths for includes will be
                                the one described by <code>CPPPATH</code> and its
                                own directory.
                                
                                <p>However, if there is a need for <code>StRoot/StXXX</code>
                                    sub-directories compilation to include every available sub-paths
                                    (other than the exceptions noted above) <a id="footnote_a">(a)</a> as a list
                                    of default path in a compiler option or if you want a default
                                    include/ directory <a id="footnote_b">(b)</a> to be always added in a
                                    default include path compiler option statement, you may request this
                                    feature to be enabled. To do that, send an email to the <code>starsoft-hn</code> mailing list.</p>
                                
                                <p>Include statement can ALWAYS refer to
                                    the relative path after the
                                    <code>StRoot/portion</code> as the <code>StRoot/</code> path is
                                    a default in <code>CPPPATH</code></p>.
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td><code>StXXXPool/</code> and
                                <code>StXXXClient/</code> and
                                <code>./</code></td>
                            <td><code>doc/</code><br/>
                                <code>local/</code><br/>
                                <code>examples/</code><br/>
                                <code>macros/</code><br/>
                                <code> kumac/</code><br/>
                                <code>test/</code><br/>
                                <code>html/</code><br/>
                                <code>images/</code><br/>
                                <code>wrk/</code><br/>
                                <code>run/</code><br/>
                                <code>include/</code>
                            </td>
                            <td>As noted above (i.e. the content of those
                                directories will be skipped by the make
                                system).
                                
                                <p>
                                    <code>local/</code>, <code>test/</code>, and <code>include/</code>
                                    are legacy names and should not be used.
                                </p>
                                <p>
                                    <code>wrk/</code> and <code>run/</code> are are
                                    discouraged for users.
                                </p>
                            </td>
                        </tr>
                        <tr>
                            <td> </td>
                            <td> </td>
                            <td>Any other name</td>
                            <td>The presence of every sub-directory will
                                create a different dynamic library. Note
                                that this is NOT the case with the other
                                name format (all compiled code would go
                                in a unique library name)
                                <p>The convention is as follows:</p>
                                <ul>
                                    <li> If the name starts with <code>St</code>, for example
                                        <code>StZZZ</code>, a library <code>StZZZ.so</code> will be
                                        created containing every compiled code
                                        available in <code>StZZZ</code> directory. In this form, the sub-directory
                                        MUST be self-sufficient i.e. all code and include
                                        (apart from the default paths) must be
                                        in the sub-directory <code>StZZZ</code></li>
                                    <li> If the name does NOT start with <code>St</code>, for
                                        example <code>WWW</code>, a library
                                        <code>StXXXPoolWWW.so</code> will be created
                                        containing all compile code available in
                                        <code>WWW</code> directory.</li>
                                </ul>
                            </td>
                        </tr>
                    </table>
                </SUBSECTION>
                
                <SUBSECTION title="Current Patterned Exceptions">
                    <p> </p>
                    <table>
                        <tr>
                            <td><code>StEventDisplay.* </code></td>
                            <td>Directories within this pattern will be compiled using the extra
                                include path pointed by the environment variable <code>QTDIR</code>.
                                The moc program will run on any include containing the <code>Q_OBJECT</code> directive,
                                <code>-DR__QT</code> define is added to <code>CXXFLAGS</code>. </td>
                        </tr>
                        <tr>
                            <td><code>StDbLib</code><br/>
                                <code>StDbBroker</code></td>
                            <td>Those are special. Compilation will consider MySQL includes and the
                                created dynamic library will be linked against MySQL </td>
                        </tr>
                        <tr>
                            <td><code>St.*Db.*</code></td>
                            <td>Any directory following this pattern will use the MySQL include as an extra include path for the <code>CPPPATH</code> directive </td>
                        </tr>
                        <tr>
                            <td><code>StTrsMaker</code> <br/>
                                <code>StRTSClient</code></td>
                            <td> Are two exceptions of kind (b) [<a href="#footnote_b">see above</a>]
                                and use their own <code>include/</code> directory as a general extraneous include path. </td>
                        </tr>
                        <tr>
                            <td><code>StHbtMaker</code></td>
                            <td> For this maker, a pre-defined list of sub-directories is being
                                added to the (<code>CPPPATH</code>).</td>
                        </tr>
                        <tr>
                            <td>
                                <code>StAssociationMaker</code><br/>
                                <code>StMuDSTMaker</code><br/>
                                <code>.*EmcUtil</code><br/>
                                <code>StEEmcPool</code><br/>
                                <code>StTofPool</code><br/>
                                <code>StRichPool</code><br/>
                                <code>Sti.* </code>
                            </td>
                            <td> This form will include in the <code>CPPPATH</code> every sub-directories
                                found one level below.
                                Only <code>macros/</code>, <code>examples/</code>, and <code>doc/</code>
                                are excluded within
                                this form noted in (a) [<a href="#footnote_a">see above</a>]. For the
                                Pool directory, the extraneous rule
                                mentioned here is additive to the one of Pool directories.</td>
                        </tr>
                    </table>
                </SUBSECTION>
            </BODY>
        </STYLEPOINT>

    </CATEGORY>
    
    <CATEGORY title="Formatting">
        <p>
            Coding style and formatting are pretty arbitrary. However, a good project
            is much easier to follow if everyone uses the same style. Individuals
            may not agree with every aspect of the formatting rules, and some of
            the rules may be hard to get used to. Even so, it is important that all
            
            project contributors
            follow the style rules so that
            
            they
            can all read and understand everyone's code easily.
        </p>
        
        
        <STYLEPOINT title="Line Length">
            <SUMMARY>
                Each line of text in your code should be at most 100 characters
                long.
            </SUMMARY>
            <BODY>
                <p>
                    Try keeping lines below 100 characters.
                    In some cases it may make sense to use much longer lines (e.g. for block editing).
                    But this should be confined to special sections in the code.
                </p>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="One Statement Per Line">
            <SUMMARY>
                Prefer one statement per line because it improves code readability.
            </SUMMARY>
            <BODY>
                <CODE_SNIPPET>
                    // Good. One statement per line.
                    if (condition) {
                        doSomething();
                    }
                    else {
                        doAnotherThing;
                    }
                </CODE_SNIPPET>
                <BAD_CODE_SNIPPET>
                    // Bad. Two statements per line.
                    if (condition) doSomething(); else doAnotherThing;
                </BAD_CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Spaces vs. Tabs">
            <SUMMARY>
                Indent code with at least 2 spaces. Prefer spaces over tabs.
            </SUMMARY>
            <BODY>
                <p>
                    Spaces are used for indentation. Do not use tabs in your code.
                    You should set your editor to emit spaces when you hit the tab
                    key. The indent of a tab depends on the setting of the editor/viewer.
                </p>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Function Declarations and Definitions">
            <SUMMARY>
                A function declaration is on one line if possible. Otherwise the parameters that do not
                fit are on the next line(s). A function definition should not be part of the class declaration
                in the header file. Inline function should be defined in the header file but only below the class
                declaration.
            </SUMMARY>
            <BODY>
                <p>
                    The return type, function name and open parenthesis are always on the same line.
                    The open curly brace is at the beginning of the new line after the last parameter
                    except for inline functions.
                </p>
                <p>
                    Example:
                </p>
                <CODE_SNIPPET>
                    ReturnType ClassName::functionName(Type parName1, Type parName2)
                    {
                        doSomething();
                        ...
                    }
                </CODE_SNIPPET>
                <p>
                    Example of an inline function on one line:
                </p>
                <CODE_SNIPPET>
                    inline int getValue() const { return mValue; }
                </CODE_SNIPPET>
                <p>Function/Method definition shall not be in the class declaration body. This reduces readability of the
                class.</p>
                <p>Bad Example:</p>
                <BAD_CODE_SNIPPET>
                    class MyClass {
                    public:
                        double energy() const {return mEnergy;}
                        double momentum() const {
                            double p2 = mEnergy*mEnergy - mMass2;
                            return sqrt(p2;)
                        }
                     };
                </BAD_CODE_SNIPPET>
                <p>Good Example:</p>
                <CODE_SNIPPET>
                    class MyClass {
                    public:
                        double energy() const;
                        double momentum() const;
                    };
                    
                    inline double MyClass::energy() const {return mEnergy;}
                    inline double MyClass::momentum() const {
                        double p2 = mEnergy*mEnergy - mMass2;
                        return sqrt(p2;)
                    }
               </CODE_SNIPPET>
                
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Pointer and Reference Expressions">
            <SUMMARY>
                No spaces around period or arrow. Pointer operators are either followed
                or preceded with a space.
            </SUMMARY>
            <BODY>
                <p>
                    The following are examples of correctly formatted pointer and
                    reference expressions:
                </p>
                <CODE_SNIPPET>
                    int value = *valuePointer;
                    int* valuePointer = &amp;value;
                    int value = myObject-&gt;getValue();
                    int value = myStruct.value;
                </CODE_SNIPPET>
                <p>
                    When declaring a pointer or reference there are two widely used and equivalent methods: one,
                    usually preferred in the C++ community, and another, introduced by Kerningham and Ritchie (the founders of C).
                </p>
                <CODE_SNIPPET>
                    // Good.
                    
                    // Pointers
                    char* myCharacter;  // typical C++ notation
                    char *myCharacter;  // Kerningham &amp; Ritchie's  notation
                    
                    // References
                    const string&amp; myString;
                    const string &amp;myString;
                </CODE_SNIPPET>
                <BAD_CODE_SNIPPET>
                    char * myCharacter;       // Bad - spaces on both sides of *
                    const string &amp; myString;  // Bad - spaces on both sides of &amp;
                </BAD_CODE_SNIPPET>
                <DECISION>
                    STAR favors the typical C++ notation, which should be the preferred style.
                </DECISION>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Boolean Expressions">
            <SUMMARY>
                In the case of a boolean expression that is longer than the <a href="#Line_Length">standard line length</a>, lines should be broken up in a consistent way. All operators should be either at the beginning or at the end of the line.
            </SUMMARY>
            <BODY>
                <p>
                    In this example, the logical AND operator is always at the end
                    of the lines:
                </p>
                <CODE_SNIPPET>
                    if (thisOneThing &gt; thisOtherThing &amp;&amp;
                        aThirdThing == aFourthThing &amp;&amp;
                        yetAnother &amp;&amp; lastOne) {
                        ...
                    }
                </CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        
        <STYLEPOINT title="Variable and Array Initialization">
            <SUMMARY>
                Prefer initialization with braces except for single-argument assignment.
            </SUMMARY>
            <BODY>
                <p>
                    Example of single-argument assignments:
                </p>
                <CODE_SNIPPET>
                    int x = 3;                           // preferred style (must using auto)
                    std::string name = "Some Name";
                    
                    int x { 3 };                         // also possible
                    std::string name{ "Some Name" };
                    std::string name = { "Some Name" };
                </CODE_SNIPPET>
                <p>
                    Note that when using <code>auto</code>, initialization through braces cannot be used.
                </p>
                <p>
                    Using <code>{}</code> for initialization is more consistent, more correct, and avoids
                    having to know about old-style pitfalls [1].
                </p>
                <p>
                    Example of variable initialization:
                </p>
                <CODE_SNIPPET>
                    Rectangle window{ 0, 0, 1024, 768 };    // preferred style
                    Rectangle window = { 0, 0, 1024, 768 }; // also possible
                    Rectangle window(0, 0, 1024, 768);      // avoid unless necessary
                </CODE_SNIPPET>
                <p>
                    There is one exception: In rare cases a class may provide an <code>std::initializer_list</code> constructor and other constructors that are hidden by the        <code>std::initializer_list</code> constructor.
                    The hidden constructor can then still be accessed with <code>()</code>.
                </p>
                <CODE_SNIPPET>
                    std::vector&lt;int&gt; v( 10, 20 ); // calls vector(size_t n, const int &amp;value)
                    std::vector&lt;int&gt; v{ 10, 20 }; // calls vector(std::initializer_list&lt;int&gt; values)
                </CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Preprocessor Directives">
            <SUMMARY>
                The hash mark that starts a preprocessor directive is
                always at the beginning of the line.
            </SUMMARY>
            <BODY>
                <p>
                    Even when preprocessor directives are within the body of
                    indented code, the directives should start at the beginning of
                    the line.
                </p>
                <CODE_SNIPPET>
                    // Good - directives at beginning of line
                    if (lopsidedScore) {
                    #if DISASTER_PENDING
                    dropEverything();
                    # if NOTIFY               // Good but not required -- Spaces after #
                    notifyClient();
                    # endif
                    #endif
                    goBackToNormal();
                    }
                </CODE_SNIPPET>
                <BAD_CODE_SNIPPET>
                    // Bad - indented directives
                    if (lopsidedScore) {
                        #if DISASTER_PENDING  // The "#if" should be at beginning of line
                        dropEverything();
                        #endif                // Do not indent "#endif"
                        goBackToNormal();
                    }
                </BAD_CODE_SNIPPET>
                <p>
                    Do not use preprocessor directives to comment out code. If it's obsolete remove it. One can always
                    retrieve it using CVS.
                </p>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Classes">
            <SUMMARY>
                Access specifiers in a class or a struct should not be indented. Lines containing methods and data member
                should be indented by at least 2 spaces, typically 4. Access specifiers should be ordered as <code>public</code>,
                <code>protected</code>, <code>private</code>. Declarations within a access specifier are to be ordered as
                Constructor, Destructor, Methods, Data Members.
            </SUMMARY>
            <BODY>
                <p>
                    The basic format for a class declaration is:
                </p>
                <CODE_SNIPPET>
                    class MyClass : public BaseClass {
                    public:
                        MyClass();    // 4 spaces indent
                        ~MyClass();
                    
                        void someFunction();
                        void someFunctionThatDoesNothing();
                        void setSomeValue(int value);
                    
                    private:
                        bool someInternalFunction();
                    
                        int mSomeValue;
                        int mSomeOtherValue;
                    };
                </CODE_SNIPPET>
                <p>
                    Things to note:
                </p>
                <ul>
                    <li> The base class name should be on the same line as the
                        derived class name, subject to the 100-character limit.
                    </li>
                    <li> Except for the first instance, the access specifier keywords should be preceded
                        by a blank line. This rule is optional for small classes.
                    </li>
                    <li> Do not leave a blank line after access specifier keywords.
                    </li>
                    <li> The <code>public</code> section should be first, followed by
                        the <code>protected</code> and finally the
                        <code>private</code> section.
                    </li>
                    <li> Generally, each access specifier appears only once in a class
                        declaration. </li>
                    <li>
                        Within each section, the declarations should be in the following order:
                        <ul>
                            <li> Constructors</li>
                            <li> Destructor</li>
                            <li> Methods</li>
                            <li> Data Members </li>
                        </ul>
                    </li>
                </ul>
                <EXTRA>
                    In certain situations you might need to use a different declaration order. For example, when using <code>decltype</code> :
                    <CODE_SNIPPET>
                        class A {
                        private:             // Early declaration of a private data member
                            int x;
                        
                        public:
                             decltype(x) foo(); // Needs x to be already declared
                        
                        private:             // the rest of the private section
                             float y;
                        };
                    </CODE_SNIPPET>
                </EXTRA>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Constructor Initializer Lists">
            <SUMMARY>
                Constructor initializer lists should be with subsequent lines indented
                properly. Alternatively, they can be all in a single line.
            </SUMMARY>
            <BODY>
                <p>
                    The preferred format for initializer lists is:
                </p>
                <CODE_SNIPPET>
                    MyClass::MyClass(int var)
                    : mSomeVar(var),             // 2 space indent
                    mSomeOtherVar(var + 1)     // lined up
                    {
                        ...
                        doSomething();
                        ...
                    }
                </CODE_SNIPPET>
                <p>
                    Another accepted format is:
                </p>
                <CODE_SNIPPET>
                    // When it all fits on one line:
                    MyClass::MyClass(int var) : mSomeVar(var), mSomeOtherVar(var + 1) {}
                </CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Namespaces">
            <SUMMARY>
                The contents of namespaces are not indented.
            </SUMMARY>
            <BODY>
                <p>
                    Namespaces do not add an extra level of
                    indentation. For example, use:
                </p>
                <CODE_SNIPPET>
                    namespace {
                    
                    void doSomething() {  // Good.  No extra indentation within namespace.
                        ...
                    }
                    
                    } // namespace
                </CODE_SNIPPET>
                <p>
                    Do not indent within a namespace:
                </p>
                <BAD_CODE_SNIPPET>
                    namespace {
                    
                    void doSomething() { // Bad.  Indented when it should not be
                        ...
                    }
                    
                    }
                </BAD_CODE_SNIPPET>
                <p>
                    When declaring nested namespaces, put each namespace on its own line.
                </p>
                <CODE_SNIPPET>
                    namespace Foo {
                    namespace Bar {
                        ...
                    }
                    }
                </CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Braces">
            <SUMMARY>
                In control constructs (<code>if</code> statements, <code>for</code> loops etc.),
                it is recommended to use curly braces even when the body of the statement fits on one line.
            </SUMMARY>
            <BODY>
                <CODE_SNIPPET>
                    // Good. Curly braces even for one statement body.
                    if (condition) {
                        return true;
                    }
                    
                    for (int i = 0; i &#60; 10; ++i) {
                        doSomething(i);
                    }
                </CODE_SNIPPET>
                <BAD_CODE_SNIPPET>
                    // Bad. No curly braces.
                    if (true)
                        return true;
                    
                    for (int i = 0; i &#60; 10; ++i)
                        doSomething(i);
                </BAD_CODE_SNIPPET>
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Horizontal Whitespace">
            <SUMMARY> Recommended guidelines:
                <ul>
                    <li> One space should be used after each keyword. </li>
                    <li> No extra spaces inside parenthesis and angle brackets (templates). </li>
                    <li> Spaces should be used around binary operators. </li>
                    <li> No space between a unary operator and its operand.</li>
                    <li> Never put trailing whitespace at the end of a line.</li>
                </ul>
            </SUMMARY>
            <BODY>
                <p>
                    Technically there is no right or wrong for whitespace as C++ does not really care about white spaces.
                    But on the other hand white spaces can make a significant difference in whether code feels foreign or easy to understand to a developer.
                    Thus, it is important that all developers become accustomed to the same style.
                    This makes the communication via code much easier and enjoyable for everybody involved.
                    Using one common whitespace style throughout a project also reduces unnecessary whitespace changes and thus makes diffs easier to read.
                </p>
                <p>
                    Example:
                </p>
                <CODE_SNIPPET>
                    int someFunction(int parameter) // No extra spaces inside parenthesis.
                    {
                        bool test = parameter &gt; 4;    // Use spaces around binary operators.
                        double value = -otherValue;   // No space between a unary operator and its operand.
                    
                        if (!test) {                  // Use one space after each keyword.
                            return 1;
                        }
                    
                        std::vector&lt;std::vector&lt;int&gt;&gt; someMatrix;
                        // No extra spaces between angle brackets (templates) in C++11.
                    
                        std::string hello = "Hello World.";
                        std::transform(hello.begin(), hello.end(), hello.begin(), [](char c) {
                             return c + 1;
                        });                           // This is the common style to embed lambdas (since C++11) in function calls.
                        return 0;
                    }
                </CODE_SNIPPET>
                <p>
                    Sometimes there are good reasons to deviate from the rules to make the code structure more visible or align similar code in different lines.
                    Feel free to insert/remove whitespace if it increases the readability / clarity of the code.
                </p>
            </BODY>
        </STYLEPOINT>
        
        
        <STYLEPOINT title="Vertical Whitespace">
            <SUMMARY>
                Use only one empty line to separate code.
            </SUMMARY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Where to put const">
            <SUMMARY>
                Put <code>const</code> before the type when defining a const variable.
            </SUMMARY>
            <BODY>
                <p>Do
                    <CODE_SNIPPET>
                        const int* foo;
                    </CODE_SNIPPET>
                    instead of
                    <BAD_CODE_SNIPPET>
                        int const *foo;
                    </BAD_CODE_SNIPPET>
                </p>
                <p>
                    Putting the <code>const</code> first is arguably more readable,
                    since it follows English in putting the "adjective"
                    (<code>const</code>) before the "noun" (<code>int</code>).
                </p>
            </BODY>
        </STYLEPOINT>
    </CATEGORY>
    
    <CATEGORY title="Comments">
     <p>
     Though a pain to write, comments are absolutely vital to keeping our
     code readable.  The following rules describe what you should
     comment and where.  But remember: while comments are very
     important, the best code is self-documenting.  Giving sensible
     names to types and variables is much better than using obscure
     names that you must then explain through comments.
     </p>
     <p>
     When writing your comments, write for your audience: the next
     
     contributor
     who will need to understand your code.  Be generous — the next
     one may be you!
     </p>
     
     <STYLEPOINT title="Comment Style">
     <SUMMARY>
     Use either the <code>//</code> or <code>/* */</code> syntax, as long
     as you are consistent.
     </SUMMARY>
     <BODY>
     <p>
     You can use either the <code>//</code> or the <code>/* */</code>
     syntax; however, <code>//</code> is <em>much</em> more common.
     Be consistent with how you comment and what style you use where.
     </p>
     </BODY>
     </STYLEPOINT>
     
     <STYLEPOINT title="File Comment Block">
         <SUMMARY>
             Every file should have a comment at the top describing its contents.
             It should contains the CVS macros $Id$ and $Log$, the primary/original author,
             as well as a brief description of the class.
         </SUMMARY>
         <BODY>
             <p>Example:</p>
             <CODE_SNIPPET>
                /***************************************************************************
                 *
                 * $Id$
                 *
                 * Author: Richard Lionheart, July 1191
                 ***************************************************************************
                 *
                 * Description: text ...
                 *
                 ***************************************************************************
                 *
                 * $Log$
                 *
                 ***************************************************************************/
             </CODE_SNIPPET>
             <p>
                 Generally a <code>.h</code> file will describe the classes
                 that are declared in the file with an overview of what they
                 are for and how they are used. A <code>.cxx</code> file
                 should contain more information about implementation details
                 or discussions of tricky algorithms. If you feel the
                 implementation details or a discussion of the algorithms
                 would be useful for someone reading the <code>.h</code>,
                 feel free to put it there instead, but mention in the
                 <code>.cxx</code> that the documentation is in the
                 <code>.h</code> file.
             </p>
             <p>
                 Do not duplicate comments in both the <code>.h</code> and
                 the <code>.cpp</code>. Duplicated comments diverge.
             </p>

          </BODY>
     </STYLEPOINT>
     
    <STYLEPOINT title="Function Comments">
     <SUMMARY>
     Declaration comments describe use of the function; comments at
     the definition of a function describe operation.
     </SUMMARY>
     <BODY>
     <SUBSECTION title="Function Declarations">
     <p>
     Every function declaration should have comments immediately
     preceding it that describe what the function does and how to
     use. This is <em>only</em> necessary of the name of the function
     is not explicative enough.
     </p>
     <p>
     These comments should be descriptive ("Resets the counter")
     rather than imperative ("Reset the counter"); the comment
     describes the function, it does not tell the function what
     to do.  In general, these comments do not describe how the
     function performs its task.  Instead, that should be left to
     comments in the function definition.
     </p>
     <p>
     When commenting constructors and destructors, remember that
     the person reading your code knows what constructors and
     destructors are for, so comments that just say something like
     "destroys this object" are not useful. It is
     quite common for destructors and constructors not to have a
     header comment.
     </p>
     </SUBSECTION>
     
     <SUBSECTION title="Function Definitions">
     <p>
     Each function definition should have a comment describing
     what the function does if there's anything tricky about how it does
     its job.  For example, in the definition comment you might
     describe any coding tricks you use, give an overview of the
     steps you go through, or explain why you chose to implement
     the function in the way you did rather than using a viable
     alternative.  For instance, you might mention why it must
     acquire a lock for the first half of the function but why it
     is not needed for the second half.
     </p>
     <p>
     Note you should <em>not</em> just repeat the comments given
     with the function declaration, in the <code>.h</code> file or
     wherever.  It's okay to recapitulate briefly what the function
     does, but the focus of the comments should be on how it does it.
     </p>
     </SUBSECTION>
     </BODY>
     </STYLEPOINT>
     
     <STYLEPOINT title="Variable Comments">
     <SUMMARY>
     In general the actual name of the variable should be descriptive
     enough to give a good idea of what the variable is used for.  In
     certain cases, more comments are required.
     </SUMMARY>
     <BODY>
     <SUBSECTION title="Class Data Members">
     <p>
     Each class data member (also called an instance variable or
     member variable) should have a comment describing what it is
     used for. This is <em>only</em> necessary of the name of the variable
     is not explicative enough.
     </p>
     This for example is a unnecessary comment
     <BAD_CODE_SNIPPET>
     private:
         int mHitCounter;   // hit counter
     </BAD_CODE_SNIPPET>
     </SUBSECTION>
     
     <SUBSECTION title="Global Variables">
     <p>
     As with data members, all global variables should have a
     comment describing what they are and what they are used for.
     For example:
     </p>
     <CODE_SNIPPET>
     // The total number of tests cases that we run through in this regression test.
     const int gNumTestCases = 6;
     </CODE_SNIPPET>
     </SUBSECTION>
     </BODY>
     </STYLEPOINT>
     
     <STYLEPOINT title="Implementation Comments">
     <SUMMARY>
     In your implementation you should have comments in tricky,
     non-obvious, interesting, or important parts of your code.
     </SUMMARY>
     <BODY>
     <SUBSECTION title="Class Data Members">
     <p>
     Tricky or complicated code blocks should have comments
     before them. Example:
     </p>
     <CODE_SNIPPET>
     // Divide result by two, taking into account that x
     // contains the carry from the add.
     for (int i = 0; i &lt; result-&gt;size(); i++) {
         x = (x &lt;&lt; 8) + (*result)[i];
         (*result)[i] = x &gt;&gt; 1;
         x &amp;= 1;
     }
     </CODE_SNIPPET>
     </SUBSECTION>
     <SUBSECTION title="Line Comments">
     <p>
     Also, lines that are non-obvious should get a comment at the
     end of the line. These end-of-line comments should be
     separated from the code by 2 spaces.  Example:
     </p>
     <CODE_SNIPPET>
     // If we have enough memory, mmap the data portion too.
     mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
     if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock)) {
         return;  // Error already logged.
     }
     </CODE_SNIPPET>
     <p>
     Note that there are both comments that describe what the
     code is doing, and comments that mention that an error has
     already been logged when the function returns.
     </p>
     <p>
     If you have several comments on subsequent lines, it can
     often be more readable to line them up:
     </p>
     <CODE_SNIPPET>
     DoSomething();                  // Comment here so the comments line up.
     DoSomethingElseThatIsLonger();  // Comment here so there are two spaces between
                                     // the code and the comment.
     {   // At least one space before comment when opening a new scope is allowed,
         // thus the comment lines up with the following comments and code.
         DoSomethingElse();  // Two spaces before line comments normally.
     }
     </CODE_SNIPPET>
     </SUBSECTION>
     <SUBSECTION title="nullptr/NULL, true/false, 1, 2, 3...">
     <p>
     When you pass in a null pointer, boolean, or literal integer
     values to functions, you should consider adding a comment about
     what they are, or make your code self-documenting by using
     constants. For example, compare:
     </p>
     <BAD_CODE_SNIPPET>
     bool success = CalculateSomething(interesting_value,
     10,
     false,
     NULL);  // What are these arguments?
     </BAD_CODE_SNIPPET>
     <p>
     versus:
     </p>
     <CODE_SNIPPET>
     bool success = CalculateSomething(interesting_value,
     10,     // Default base value.
     false,  // Not the first time we're calling this.
     NULL);  // No callback.
     </CODE_SNIPPET>
     <p>
     Or alternatively, constants or self-describing variables:
     </p>
     <CODE_SNIPPET>
     const int kDefaultBaseValue = 10;
     const bool kFirstTimeCalling = false;
     Callback *null_callback = NULL;
     bool success = CalculateSomething(interesting_value,
     kDefaultBaseValue,
     kFirstTimeCalling,
     null_callback);
     </CODE_SNIPPET>
     </SUBSECTION>
     
     <SUBSECTION title="Don'ts">
     <p>
     Note that you should <em>never</em> describe the code
     itself. Assume that the person reading the code knows C++
     better than you do, even though he or she does not know what
     you are trying to do:
     </p>
     <BAD_CODE_SNIPPET>
     // Now go through the b array and make sure that if i occurs,
     // the next element is i+1.
     ...        // Geez.  What a useless comment.
     </BAD_CODE_SNIPPET>
     </SUBSECTION>
     </BODY>
     </STYLEPOINT>
     
     <STYLEPOINT title="Punctuation, Spelling and Grammar">
     <SUMMARY>
     Pay attention to punctuation, spelling, and grammar; it is
     easier to read well-written comments than badly written ones.
     </SUMMARY>
     <BODY>
     <p>
     Comments should be as readable as narrative text, with proper
     capitalization and punctuation. In many cases, complete sentences are
     more readable than sentence fragments. Shorter comments, such as
     comments at the end of a line of code, can sometimes be less formal, but
     you should be consistent with your style.
     </p>
     <p>
     Although it can be frustrating to have a code reviewer point
     out that you are using a comma when you should be using a
     semicolon, it is very important that source code maintain a
     high level of clarity and readability.  Proper punctuation,
     spelling, and grammar help with that goal.
     </p>
     </BODY>
     </STYLEPOINT>

     <STYLEPOINT title="Commenting Out Code">
          <SUMMARY>
            Do not leave commented out code in the source file after testing. Proper utilization of revision control system can be relied on to retrieve any version of the code.
          </SUMMARY>
          <BODY>
            <p>
            A commented code is a rudiment from the times when there were no sophisticated revision control systems available.
            The developer would sometime stash a feature for later consideration right there in the code -- but often would forget about it.
            The other developers do not care about such unfinished or under-implemented features, which just draws their attention from the real code.
            Proper utilization of revision control systems allow us to save and test new features on branches without polluting the main trunk with commented code.
            This rule also extends to the notorious use of <a href="#Preprocessor_Directives">preprocessor directives</a> to comment out code.
          </p>
          </BODY>
        </STYLEPOINT>
     </CATEGORY>
    
    <CATEGORY title="Other">
        
        <STYLEPOINT title="Printing Messages in STAR">
            <SUMMARY>
                For printing messages in the STAR framework use the <code>StMessage</code> message manager package.
            </SUMMARY>
            <BODY>
            <p>
                The so called STAR logger is documented <a href="http://www.star.bnl.gov/cgi-bin/protected/cvsweb.cgi/~checkout~/StRoot/StStarLogger/doc/StStarlogger.html">here</a>.
            </p>
            <p>
                For all messages from a given portion of code, use a unique string, like:
            </p>
                
            <CODE_SNIPPET>
            LOG_XXX &lt;&lt; "StZdcVertexMaker::Init(): idid not find ZdcCalPars." &lt;&lt; endm;
            </CODE_SNIPPET>
            where <code>XXX</code> is either
                <CODE_SNIPPET>
                    DEBUG
                    INFO
                    WARN
                    ERROR
                    FATAL
                    QA
                </CODE_SNIPPET>
                    Then, you can filter in/out the wanted / unwanted messages using
                    the logger filter mechanism. The Logger
                    is well documentation and its use is encouraged.
            </BODY>
        </STYLEPOINT>
        
        <STYLEPOINT title="Handling Error Conditions in STAR Framework">
            <SUMMARY>
                To exit your code on an error condition in the STAR framework,
                return one of the STAR defined return codes from your Maker.
            </SUMMARY>
            <BODY>
                <p>
                    The error codes are defined in the <code>ERreturnCodes</code> enumeration.
                </p>
                <CODE_SNIPPET>
                enum EReturnCodes {
                    kStOk=0,  // OK
                    kStWarn,  // Warning, something wrong but work can be continued
                    kStEOF,  // End Of File
                    kStErr,  // Error, drop this and go to the next event
                    kStFatal      // Fatal error, processing impossible
                };
                </CODE_SNIPPET>
           </BODY>
        </STYLEPOINT>
 
 
 
    </CATEGORY>

    <CATEGORY title="Exceptions to the Rules">
        <p>
            The coding conventions described above have to be followed.  However,
            like all good rules, these sometimes have exceptions.
        </p>
        
        <STYLEPOINT title="Existing Non-Conformant Code">
            <SUMMARY>
                It is permissible to deviate from the rules when dealing with code that does not
                conform to this style guide. For example, in naming something that is analogous
                to an existing C or C++ entity then the existing naming convention
                scheme can be followed.
            </SUMMARY>
            <BODY>
                <p>
                    To modify code that was written to
                    specifications other than those presented by this guide, it may be necessary to
                    deviate from these rules in order to stay consistent with
                    the local conventions in that code.  In case of doubt the original author or
                    the person currently
                    responsible for the code should be consulted.  Remember that <em>consistency</em>
                    also includes local consistency.
                </p>
                <p>
                    For example, when importing a full class from somewhere else
                    it is allowed to keep the naming scheme
                    and the style as is. To use the "correct" naming and formatting scheme (described
                    in this document),  then to be consistent, the whole coding standard must be applied to the
                    whole class. <br/>
                    Note: in the case that the whole formatting is changed then there should be 
                    one commit for the style changes and one for the actual code
                    changes.
                </p>
            </BODY>
        </STYLEPOINT>
    </CATEGORY>
    
    <PARTING_WORDS>
        <p>
            Use common sense and <em>BE CONSISTENT</em>.
        </p>
        <p>
            When editing code, take a few minutes to look at the
            code and determine its style.
        </p>
        <p>
            The point about having style guidelines is to have a common
            vocabulary of coding so people can concentrate on what the programmer
            is saying, rather than on how he/she is saying it. Global style rules
            are presented here so people know the vocabulary. However,
            local style is also important.  If the code added to a file
            looks drastically different from the existing code around it,
            the discontinuity throws readers out of their rhythm when they
            go to read it. Try to avoid this.
        </p>
        
     </PARTING_WORDS>
    
</GUIDE>
